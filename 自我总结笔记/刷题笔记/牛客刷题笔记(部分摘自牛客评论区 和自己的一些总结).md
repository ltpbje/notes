#  牛客网刷题

### 哈希表
根据**关键字**来存数据同样也根据**关键字**来找数据

设哈希表长为8，哈希函数为Hash (key)=key%7。**初始记录关键字**序列为(32，24，15，27，20，13)，用链地址法作为解决冲突方法的平均查找长度是（）
A
	1.4
B
	1.5
C
	1.6
D
	1.7


哈希表和我们日常生活息息相关。比如，当你在电脑上搜索文件时，电脑会用一种快速的方法帮你找到文件，这个方法就是哈希表。它还用在数据库中快速检索数据，以及在编程中处理大量数据时提高效率。

### 四叉树 二叉树

n个节点的树 有n-1个边 因此有**n-1个非空指针** n个节点的四叉树有 **4n个指针**


一个包含n个节点的四叉树，每个节点都有四个指向孩子节点的指针，这4n个指针中有多少个空指针（）

A

​	2n+1
​	B
​		3n-1
​	C
​		3n
​	D
​		3n+1


D

**n个结点为一棵树则有n-1条边**，**因此有n-1个非空指针**

空指针个数4*n-(n-1)=3*n+1
	发布于 2017-01-26 19:59

赖卓成2018102015432

作者：丨太阳与月亮丨
	[链接 ](https://www.nowcoder.com/exam/test/84513057/submission?examPageSource=Intelligent&pid=59383072&testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fintelligent%3FquestionJobId%3D10%26tagId%3D273590%26type%3Dbase&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91)
	来源：牛客网

### 数组的一些方法
**sort()会改变原数组**

sort() 方法就地对数组的元素进行排序，并返回对相同数组的引用。默认排序是将元素转换为字符串，然后按照它们的 UTF-16 码元值升序排序。
会改变数组的方法： 


**slice() 不会改变原数组**
**slice() 方法返回一个新的数组对象**，这一对象是一个由 `start` 和 `end` 决定的原数组的浅拷贝（`包括 start`，`不包括 end`），其中`start` 和 `end`代表了数组元素的索引。原始数组不会被改变。
push()
pop()
shift()
unshift()
splice()
sort()
reverse()

不会改变数组的方法： 
forEach()
filter()
concat() 
slice()
map()

作者：牛客816403475号
链接：https://www.nowcoder.com/exam/test/84380429/submission?examPageSource=Intelligent&pid=59308471&testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fintelligent%3FquestionJobId%3D10%26tagId%3D21003&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91
来源：牛客网

### 构造函数里面的 return值
如果以下程序的输出结果是false，则①式可以替换为（） return test;
```js
const test = {
  rules: false
};
function Build() {
    this.rules = true;
        ①
}
const build = new Build();
console.log(build.rules);
```
在构造函数里面，如果不写return的话默认就是返回创建的实例对象，但是如果加入了return的话，如果return的是一个基本数据类型的话比如，boolean,number,undefined等那么仍然返回实例对象，如果返回的是一个对象的话，则返回该对象，原本的指向实际对象的this会被无效化

作者：大米哥哥
链接：https://www.nowcoder.com/exam/test/84356029/submission?examPageSource=Intelligent&pid=59293077&testCallback=https%3A%2F%2Fwww.nowcoder.com%2Fexam%2Fintelligent%3FquestionJobId%3D10%26tagId%3D21003&testclass=%E8%BD%AF%E4%BB%B6%E5%BC%80%E5%8F%91
来源：牛客网

### 数组常用方法记忆技巧
1. **添加和删除元素**
   - `push()`：向数组末尾添加一个或多个元素。
   - `pop()`：移除数组的最后一个元素，并返回该元素。
   - `shift()`：移除数组的第一个元素，并返回该元素。
   - `unshift()`：向数组开头添加一个或多个元素。
   - `splice()`：从数组中添加或删除元素。

2. **搜索元素**
   - `indexOf()`：查找元素的索引，如果不存在返回-1。
   - `lastIndexOf()`：从数组末尾开始查找元素的索引。
   - `includes()`：检查数组是否包含某个元素。

3. **遍历数组**
   - `forEach()`：对数组中的每个元素执行一次提供的函数。
   - `map()`：创建一个新数组，其结果是该数组中的每个元素是调用一次提供的函数后的返回值。
   - `filter()`：创建一个新数组，包含通过所提供函数实现的测试的所有元素。
   - `reduce()`：对数组中的值进行汇总，返回一个值。

4. **数组转换**
   - `slice()`：提取原数组的一部分，并返回一个新数组。
   - `concat()`：合并两个或多个数组。

5. **排序数组**
   - `sort()`：对数组元素进行排序。
   - `reverse()`：颠倒数组中元素的顺序。


**记忆技巧**：
- **添加和删除**：想象你在玩一堆积木，`push` 和 `pop` 就像是在积木堆的顶部添加或移除积木，而 `shift` 和 `unshift` 就像是在积木堆的底部操作。
- **搜索元素**：想象你在人群中寻找你的朋友，`indexOf` 是从前面开始找，`lastIndexOf` 是从后面开始找，`includes` 是检查你的朋友是否在人群中。
- **遍历数组**：想象你在为每个苹果（数组中的元素）做不同的处理，`forEach` 是简单地查看每个苹果，`map` 是给每个苹果贴标签，`filter` 是选出好的苹果，`reduce` 是计算所有苹果的总重量。
- **数组转换**：`slice` 是切一块苹果派，`concat` 是把几块派拼在一起。
- **排序数组**：`sort` 是把苹果按大小排序，`reverse` 是把苹果堆的顺序颠倒过来。

通过这些生动的比喻和记忆技巧，你可以更容易地记住JavaScript数组的常用方法。

### 数据比较

下列表达式中，返回值为true的是（）

①Object.is(NaN,NaN)

②Object.is(+0,-0)

③NaN === NaN

④+0 === -0

①④



```js
console.log(null == false);             //           false
console.log(null == true);            //   false
console.log(undefined == false);//false
console.log(undefined == true); //false
console.log(undefined == null); //true
console.log(undefined == undefined);// true
console.log(null == null); //true  

NaN == NaN // false
 NaN === NaN // false

 // indexOf方法无法识别数组的NaN成员
 [NaN].indexOf(NaN) // -1

 // 向 Set 数据结构中加入值时认为NaN等于自身
 let set = new Set();
 set.add(NaN);
 set.add(NaN);
 console.log(set); // Set {NaN}

 // Object.is()方法认为NaN等于NaN
 Object.is(NaN, NaN) // true
 +0 === -0 //true
 Object.is(+0, -0) // false

 // ES7中新增的数组实例方法，includes()方法认为NaN等于自身
 [1, 2, NaN].includes(NaN) // true

```
作者：宇智波星橙
链接：https://www.nowcoder.com/exam/test/84296388/submission?pid=59257510&pageSource=testHistory
来源：牛客网

### Vue路由守卫



> 全局路由守卫的钩子函数有：beforeEach（全局前置守卫）、beforeResolve（全局解析守卫）、afterEach（全局后置守卫） 名字中间没有“Route”，  组件级路由守卫的钩子函数才有“Route”
>
> 作者：牛客264234369号
> 链接：https://www.nowcoder.com/exam/test/81219049/submission?pid=57475562
> 来源：牛客网

> 全局：beforeEach(前置守卫)，beforeResolve(解析守卫)，afterEach(后置守卫) 
>
> 单个路由守卫：beforeEnter 
>
>   局部路由守卫：beforeRouteEnter（前置守卫），beforeRouteLeave(后置守卫)，beforeRouteUpdate（路由改变守卫）
>
> 作者：一世长安_
> 链接：https://www.nowcoder.com/exam/test/81219049/submission?pid=57475562
> 来源：牛客网

在Vue中，路由守卫（Route Guards）是一种权限控制机制，用于在路由跳转发生之前或之后执行代码，从而控制页面的访问权限。Vue Router提供了多种路由守卫，包括==全局守卫、路由独享的守卫和组件内的守卫==。

 1. 全局路由守卫

全局路由守卫可以在路由配置之前或之后全局应用，适用于所有路由。

**例子：**

```javascript
// 在router/index.js中
import Vue from 'vue';
import Router from 'vue-router';
import Home from '@/components/Home';
import Admin from '@/components/Admin';

Vue.use(Router);

const router = new Router({
  routes: [
    { path: '/', component: Home },
    { path: '/admin', component: Admin }
  ]
});

// 全局前置守卫
router.beforeEach((to, from, next) => {
  if (to.path === '/admin') {
    // 判断用户是否登录
    if (/* 用户未登录 */) {
      next({ path: '/login' }); // 未登录重定向到登录页
    } else {
      next(); // 已登录放行
    }
  } else {
    next(); // 其他路由放行
  }
});

export default router;
```

2. 单个路由守卫

单个路由守卫是针对特定路由的，可以在路由配置中定义。

**例子：**

```javascript
// 在router/index.js中
const router = new Router({
  routes: [
    { path: '/', component: Home },
    {
      path: '/admin',
      component: Admin,
      beforeEnter: (to, from, next) => {
        // 判断用户是否登录
        if (/* 用户未登录 */) {
          next({ path: '/login' }); // 未登录重定向到登录页
        } else {
          next(); // 已登录放行
        }
      }
    }
  ]
});
```

 3. 组件内部路由守卫

组件内部路由守卫是直接在组件内部定义的，可以在组件的生命周期钩子中使用。

**例子：**

```javascript
// 在Admin.vue组件中
export default {
  template: '...',
  beforeRouteEnter(to, from, next) {
    // 在渲染该组件的对应路由被确认前调用
    // 不能获取组件实例 `this`，因为当守卫执行前，组件实例还没被创建
    if (/* 用户未登录 */) {
      next({ path: '/login' }); // 未登录重定向到登录页
    } else {
      next(); // 已登录放行
    }
  },
  beforeRouteUpdate(to, from, next) {
    // 当路由改变且该组件被重用时被调用
    // 可以获取组件实例 `this`
    if (/* 用户未登录 */) {
      next(false); // 强制停止路由变更
    } else {
      next(); // 允许路由变更
    }
  }
};
```

在实际应用中，你需要根据实际的登录状态和业务逻辑来实现具体的权限控制逻辑。

### 原型链问题
以下代码执行后，a.x 和 b.x 的结果分别为（）

2  undefined
```js
function A(x){
  this.x = x;
}
A.prototype.x = 1;

function B(x){
  this.x = x;
}
B.prototype = new A(); //B.prototype = {x:undefined} 
var a = new A(2), b = new B(3);//b = {x:3}
delete b.x;//b = {} b.__proto__ ={x:undefined}

```
链接：https://www.nowcoder.com/questionTerminal/133157fbfae443d18780d5cec6d3334e?
来源：牛客网

b的prototype=new A(),想错的可能都认为构造函数的x没有赋值就自动去原型下找，错了，

如果构造函数没有x才会去原型下找，
如果有x但是没有赋值，则是undefined,相当于x=undefined.就不会进入原型链了

### 不能冒泡的事件

以下是JavaScript中不能冒泡的事件列表：

focus：当元素获得焦点时触发。
	blur：当元素失去焦点时触发。
	focusin：当元素即将获得焦点时触发。
	focusout：当元素即将失去焦点时触发。
	load：当页面或图片等资源加载完成时触发。
	unload：当页面即将卸载时触发。
	resize：当浏览器窗口大小改变时触发。
	scroll：当文档或元素滚动时触发。
	DOMContentLoaded：当DOM树完全加载并解析完成时触发，不等待样式表、图片和子框架完成加载。
	mouseenter：当鼠标指针进入一个元素的边界时触发。
	mouseleave：当鼠标指针离开一个元素的边界时触发。
	change：当元素的值发生变化时触发（通常用于表单元素）。
	input：当<input>, <select>, 或 <textarea>元素的值发生变化时触发。

### 堆排序

题目

对关键码序列{9, 27, 18, 36, 45, 54, 63}进行堆排序，输出2个最大关键码后的剩余堆是（D）。

A

{9, 18, 27, 36, 45}D

B

{9, 18, 45, 27, 36}

C

{45, 9, 18, 27, 36}

D

{45, 36, 18, 9, 27}


1. 构建最大堆：从无序数组开始，将其构建成一个最大堆。在这个过程中，每个父节点都比其子节点大。
2. 交换并调整堆：将堆顶元素（最大值）与数组的最后一个元素交换 从堆中拿出这个最大值，然后调整堆，使其再次成为最大堆。
3. 重复过程：重复上述过程，直到堆中只剩下一个元素，此时数组已经完成排序。


### undefined隐式转换成Number类型值为NaN

执行下列选项的程序，输出结果不是undefined的是（）

```js
A function fn(a,b){
	console.log(b);
}
fn(1);
B console.log(undefined + 1);
C var arr = [];
arr.length = 2;
arr[0] = 1;
console.log(arr[1]);
D
function fun(){}
console.log(fun());
```

 **考点：\**undefined隐式转换成Number类型值是啥\**** 

    **1）Number(undefined) 结果是NaN**，所以NaN+1 = NaN 
    
    **2）Number(null)** 结果是0 
    
    3）Number('a')结果是NaN 
    
    4) Number('')结果是0 
    
    5) Number(true)结果是1 
    
    6) Number(false)结果是0 
    
    7) Number([])结果是0 
    
    8) Number({})结果是NaN

作者：笨笨只会灭火
	链接：https://www.nowcoder.com/exam/test/84060625/submission?pid=59133776
	来源：牛客网

### 刷题时候遇到的问题-原型链问题
```js
var A = {n:4399};
var B = function(){this.n = 9999};
var C = function(){var n = 8888};
B.prototype = A;
C.prototype = A;
var b = new B();
var c = new C();
A.n++; // 这里增加了A对象的n属性值
console.log(b.n); // 输出 9999，因为b对象有自己的n属性
console.log(c.n); // 输出 4400，因为c对象没有自己的n属性，所以访问A对象的n属性
```

-     ==delete 操作符用于删除对象的某个属性；==如果没有指向这个属性的引用，那它最终会被释放。

`typeof` 能判断类型有：number、string、boolean、symbol、undefined、function；  **object、****array、null** 的变量都返回 object 

<img src='https://i-blog.csdnimg.cn/blog_migrate/2aa10cee5ae01d3876997c82beb48228.png'>

`Object.prototype.toString() `为 Object 对象的实例方法，默认情况下（即不重写该方法），返回参数的类型字符串。

<img src='https://i-blog.csdnimg.cn/blog_migrate/bb82f556e43db1c36974f0db1a77f88b.png'>

Array 为` js `的原生对象，它有一个静态方法：`Array.isArray()`，能判断参数1是否为数组 

 

   <img src='https://i-blog.csdnimg.cn/blog_migrate/2aa10cee5ae01d3876997c82beb48228.png'>

### class和let一样都有暂时性死区，在被声明前无法访问

也就是在当前作用域能找到，但是要在声明后才能访问
**`es6中的class`和`let const`一样都不存在提升
（实际存在提升，只是因为`TDZ`的作用，并不会像var那样得到undefined,而是直接抛出错误）**

临时死区（Temporal Dead Zone），简写为` TDZ`。

`let` 和 `const` 声明的变量不会被提升到[作用域](https://so.csdn.net/so/search?q=作用域&spm=1001.2101.3001.7020)顶部，如果在声明前访问这些变量，会导致错误：

```js
原来的代码
var a = 1;
function test(){
    //console.log(a) 位置A
class a {}
   // console.log(a) 位置B
}
test();

实际上提升后的
var a = 1;
function test(){
    console.log(a) 位置A //在test()作用域内找得到a
//是一个class但是存在TDZ暂时性死区，访问报错
    class a {}
    console.log(a) 位置B //a已经声明创建出来了
}
test()
```

-   in操作符，对于数组属性需要指定数字形式的**索引值**来表示数组的属性名称（固有属性除外，如length）。  
-    所以说在这里，1 in [1]并不是表示数字1在不在数组里。而是表示数组中含不含有1这个索引index值。 数组长度为1，所以只含有的index值为0，这个表达式返回`fasle`。  

- 任何数值除以0都会导致错误而终止程序执行。但是在 JavaScript 中，**会返回出特殊的值**，因此不会影响程序的执行。  
-    比0大的数除以0，则会得到无穷大，所以 js 用 Infinity 来显示出来。  
-    也就是1/0得到的是Infinity。`isNaN(1/0)`返回的是`false`。但是`isNaN(0/0)`返回的就是true  

1 && 2 > 1，先判断右边的表达式，2>1返回true。1 && true返回的结果也是true。\>号的权重大于&&，所以先是右边开始

**Array对象方法**

<img src= 'https://i-blog.csdnimg.cn/blog_migrate/9522aa804b255cf785b62e7e6e383232.png'>

` js`基本数据类型包括： 

 

  1.Number 

  `typeof`  123 =>"number"  

   2.String  

   typeof  `'abc'` =>"string"  

   3.Boolean  

   `typeof   true `=>"boolean"  

    4.Function   

   ` typeof   console.log() `=>"function"   

    5.Object   

   `typeof   `null    =>"object"  

 `  typeof  ` { } =>"object"  

  ` typeof  ` [ ] =>"object"  

   6.Undefined  

   `typeof`   undefined =>"undefined"  

   题中的Array属于数组对象  

   `typeof` new Array()  =>"object"  

   值得一提的是`typeof`打印出的类型都是字符串类型，且首字母小写  

   例如：typeof(typeof undefined) =>"string"  

# 类

类的本质是函数，实际上，ES6中的类可以视为ES5中构造函数的另一种写法

类的所有实例方法均定义在类的原型对象上，因此，在类内定义的实例方法和在类的原型对象上定义方法是等价的





数组的sort()方法 

**升序排序 return a - b； 降序排序 return b - a。**  

==setMonth(n)==这里是**0-11分别对应1-12月**
由于存在变量提升，在if语句执行之前会先使用var声明变量a，并且声明时是在全局作用域下，因此变量a自动成为window对象的属性，故a in window的返回结果为true，使用“!”将条件取反后返回结果为false，所以不会执行if中的赋值语句，a值为undefined

数组的方法

pop（）方法用于删除数组的最后一个元素，并返回被删除的最后一个元素，这样的话数组就被改变了。 splice()方法可以对数组中已经存在元素进行删除，也可以添加元素到数组中。 sort()方法对数组中所有的元素都进行排序，如果没有提供比较函数compareFunction，则按照字符串的Unicode码的顺序进行排序。 所以以上三种方法都改变了数组。 而  concat()方法用于连接两个或多个数组。该方法不会改变现有的数组，而仅仅会返回被连接数组的一个副本，返回一个新的数组。该数组是通过把所有的arrayX参数添加到arryaObject中生成的，如果要进行 concat()操作的参数是数组，那么添加的是数组中的元素，而不是数组。